$date
	Tue May 23 15:43:34 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module testbench $end
$var wire 32 ! somaimm_tb [31:0] $end
$var wire 32 " somafour_tb [31:0] $end
$var wire 64 # res_tb [63:0] $end
$var wire 7 $ opcode_tb [6:0] $end
$var wire 64 % imm_tb [63:0] $end
$var wire 1 & flag_tb $end
$var wire 64 ' doutMem_tb [63:0] $end
$var wire 32 ( doutIR_tb [31:0] $end
$var wire 64 ) doutB_tb [63:0] $end
$var wire 64 * doutA_tb [63:0] $end
$var wire 64 + S2_tb [63:0] $end
$var wire 64 , S1_tb [63:0] $end
$var wire 5 - Rw_tb [4:0] $end
$var wire 5 . Rb_tb [4:0] $end
$var wire 5 / Ra_tb [4:0] $end
$var wire 32 0 PC_tb [31:0] $end
$var wire 32 1 IR_tb [31:0] $end
$var wire 32 2 C_tb [31:0] $end
$var reg 1 3 clock_tb $end
$var reg 1 4 sinalMux1_tb $end
$var reg 1 5 sinalMux2_tb $end
$var reg 1 6 weIR_tb $end
$var reg 1 7 weMem_tb $end
$var reg 1 8 wePC_tb $end
$var reg 1 9 weReg_tb $end
$scope module hii $end
$var wire 32 : palavra [31:0] $end
$var wire 7 ; opcode [6:0] $end
$var wire 12 < imm_field [11:0] $end
$var wire 64 = imm [63:0] $end
$upscope $end
$scope module huu $end
$var wire 1 3 clock $end
$var wire 1 6 r_enable $end
$var wire 32 > data_in [31:0] $end
$var reg 32 ? data_out [31:0] $end
$var reg 7 @ opcode [6:0] $end
$upscope $end
$scope module ihs $end
$var wire 32 A imm_some [31:0] $end
$var wire 32 B four_some [31:0] $end
$var wire 1 & flag $end
$var wire 32 C S3 [31:0] $end
$upscope $end
$scope module its $end
$var wire 64 D imm [63:0] $end
$var wire 32 E soma [31:0] $end
$var wire 32 F dout_pc [31:0] $end
$upscope $end
$scope module itt $end
$var wire 32 G soma [31:0] $end
$var wire 32 H dout_pc [31:0] $end
$upscope $end
$scope module uhh $end
$var wire 1 3 clock $end
$var wire 32 I data_in [31:0] $end
$var wire 1 8 r_enable $end
$var reg 32 J data_out [31:0] $end
$upscope $end
$scope module utH $end
$var wire 32 K ads [31:0] $end
$var wire 32 L dout [31:0] $end
$var wire 5 M rs2 [4:0] $end
$var wire 5 N rs1 [4:0] $end
$var wire 5 O rd [4:0] $end
$var wire 7 P opcode [6:0] $end
$upscope $end
$scope module utt $end
$var wire 5 Q Ra [4:0] $end
$var wire 5 R Rb [4:0] $end
$var wire 5 S Rw [4:0] $end
$var wire 1 3 clk $end
$var wire 1 9 we $end
$var wire 64 T din [63:0] $end
$var reg 64 U doutA [63:0] $end
$var reg 64 V doutB [63:0] $end
$upscope $end
$scope module utu $end
$var wire 64 W din [63:0] $end
$var wire 1 7 we $end
$var wire 64 X dout [63:0] $end
$var wire 64 Y ads [63:0] $end
$upscope $end
$scope module utv $end
$var wire 64 Z doutB [63:0] $end
$var wire 64 [ imm [63:0] $end
$var wire 1 4 sinalMux $end
$var wire 64 \ S1 [63:0] $end
$upscope $end
$scope module uut $end
$var wire 64 ] a [63:0] $end
$var wire 64 ^ au [63:0] $end
$var wire 64 _ b [63:0] $end
$var wire 64 ` bu [63:0] $end
$var wire 32 a sinal [31:0] $end
$var wire 64 b soma [63:0] $end
$var wire 1 c flagBLT $end
$var wire 1 d flagBEQ $end
$var wire 1 & flag $end
$upscope $end
$scope module uvv $end
$var wire 64 e dout [63:0] $end
$var wire 1 5 sinalMux $end
$var wire 64 f soma [63:0] $end
$var wire 64 g S2 [63:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx g
bx f
bx e
xd
xc
bx b
b100000100000101100011 a
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 `
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 _
bx ^
bx ]
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 \
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
b10 S
b1 R
b0 Q
b1100011 P
b10 O
b0 N
b1 M
b100000100000101100011 L
b101 K
b101 J
bx I
b101 H
b1001 G
b101 F
bx E
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 D
bx C
b1001 B
bx A
bx @
bx ?
b100000100000101100011 >
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 =
bx <
b1100011 ;
bx :
x9
08
07
16
05
04
03
bx 2
b100000100000101100011 1
b101 0
b0 /
b1 .
b10 -
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 ,
bx +
bx *
bx )
bx (
bx '
x&
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00 %
b1100011 $
bx #
b1001 "
bx !
$end
#10
1&
0d
1c
b1111111111111111111111111111111111111111111111111111111111111001 #
b1111111111111111111111111111111111111111111111111111111111111001 Y
b1111111111111111111111111111111111111111111111111111111111111001 b
b1111111111111111111111111111111111111111111111111111111111111001 f
b1101 2
b1101 C
b1101 I
b1101 !
b1101 A
b1101 E
b1000 `
b1000 ,
b1000 \
b1000 _
b1000 %
b1000 =
b1000 D
b1000 [
b10 <
b1 )
b1 V
b1 W
b1 Z
b1 ^
b1 *
b1 U
b1 ]
b100000100000101100011 (
b100000100000101100011 :
b100000100000101100011 ?
13
#20
03
#30
13
#40
03
#50
13
#60
03
#70
b1 +
b1 T
b1 g
b1 '
b1 X
b1 e
13
17
#80
03
